
---
layout: post
category : miscellanous
tagline: "Mysterious google two step authentication - in debug"
tags : [google,php,twofactor authentication, RFC6238]
---
{% include JB/setup %}

#Introduction
 I hope you have enabled your google account for two step authentication? If not -I strongly recommend to do so.  Do you know the nature of the code generated by Google Authenticator?  There are no myth here  - this is just implementation of RFC6238. And even more - you can add new level of security to your application very easy without need to use some monstrous security library.

I will use PHP in this article - this means that server side can use this code to validate the client one. But nothing stops you from implementing OTP generation algorythm in javascript.

#Background
2-step verification drastically reduces the chances of having the personal information in your Google account stolen by someone else. Why? Because hackers would have to not only get your password and your username, they'd have to get your personal key used to generate 6 digit combination.

How this combination is generated? Let's move through process:

Assume, that secret code in base32 is  **GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ** (this is actually base32 encoded secret key  **12345678901234567890**.

Why base32 and not base64 is used? My guess takes into consideration following points:

The resulting character set is all one case (usually represented as uppercase), which can often be beneficial when using a case-insensitive filesystem, spoken speech, or human memory.
The alphabet was selected to avoid similar-looking pairs of different symbols, so the strings can be accurately transcribed by hand. (For example, the symbol set omits the symbols for 1, 8 and zero, since they could be confused with the letters 'I', 'B', and 'O'.)
The result can be included in a URL without encoding any characters.
in other words  -  encoded message is much easier to remember than base 64.

 Variance of the code is time (to be more precise, it's 30sec intervals). Bearing in mind, that not all devices use ntp to synchronize, we might want to check 3-5 sequential codes to be sure, that right code is entered. The more secure is your solution - the less 30sec intervals you might want to check,



 Let us take current Unix Time Stamp:


UnixTimeStamp (time()/30): **44376117.366667**
 and calculate  HOTP - onetime password based on HMAC  (http://en.wikipedia.org/wiki/HOTP)

What do we need to calculate 6 digit code:

Take trunc of the value above - **44376117** and convert to hex **2a52035**

Pack to byte string:

<pre><code class="javascript">

5(35)
 (20)
¥(a5)
<(2)
 (0)
 (0)
 (0)
 (0)

</code></pre>

 If hex string has lesser than 16 characters, pad it from the left using 0 character.

Decimal representation:

<pre><code class="javascript">
 0 0 0 0 2 165 32 53
</code></pre>

 Now calculate sha1 HMAC(Hash-based Message Authentication Code http://en.wikipedia.org/wiki/HMAС )

<pre><code class="javascript">
hash_hmac ('sha1', '...<¥ 5...', 12345678901234567890)
</code></pre>

Result:  **af2b88048dc8979b528af4e37085061d88aaaaa5**
 hash_hmac is a commonly available crypthographic function, you may find it in any crypthographic library or toolkit.

Let us convert it to 6 digit sequence:

 Step А: convert into hex  array

<pre><code class="php">
Array ( [0] => af [1] => 2b [2] => 88 [3] => 04 [4] => 8d [5] => c8 [6] => 97 [7] => 9b [8] => 52 [9] => 8a [10] => f4 [11] => e3 [12] => 70 [13] => 85 [14] => 06 [15] => 1d [16] => 88 [17] => aa [18] => aa [19] => a5 )
</code></pre>
Step B Transform each hex in the array to it's decimal form

<pre><code class="php">
Array ( [0] => 175 [1] => 43 [2] => 136 [3] => 4 [4] => 141 [5] => 200 [6] => 151 [7] => 155 [8] => 82 [9] => 138 [10] => 244 [11] => 227 [12] => 112 [13] => 133 [14] => 6 [15] => 29 [16] => 136 [17] => 170 [18] => 170 [19] => 165 )
</code></pre>

Step C  Take 19-th array element (in this case 165)

and perform bitwise operator & on mask 0xf   - we receive 5 for current example.

<pre><code class="php">

(hmac_result[offset+0] & 0x7f) << 24 = 200& 0x7f) << 24 = 11001000&100100111<< 24 = 1001000 << 24 =1001000000000000000000000000000=1207959552

(hmac_result[offset+1] & 0xff) << 16 = 151& 0xff) << 16 = 10010111&1001010101<<
    16=10111 << 16 = 100101110000000000000000

(hmac_result[offset+2] & 0xff) << 8 = 155& 0xff) << 8 = 10011011&1001010101<< 8=10111
    << 16 = 1001101100000000

(hmac_result[offset+3] & 0xff) = 82& 0xff) = 1010010&1001010101=10111 << 16 =1010010

1001000000000000000000000000000 | 100101110000000000000000 | 1001101100000000 | 1010010 =
1001000100101111001101101010010 = 1217895250

</code></pre>


 Step D: take the result

1217895250 and retrieve modulus of division on 10 pow length of the needed sequence (for 6 it is 1000000)

Let's devide - we will get 1217.89525, thus modulus is - 895250.

We are finished our algorythm: this is result, generated , in particular,by Google Authenticator application: 895250.

#Code
 Let's use PHP to implement algorythm above.

Required libraries: to simplify the development and not reinvent the wheel, it is always useful to try to find if someone else has implemented it already. For php I have adopted:

a) Base32 implementation for PHP by Bryan Ruiz

b) PHP HMAC hash implementation from community feedbacks on http://php.net/manual/ru/function.hash-hmac.php

in a result proof of concept implementation of RFC6238 have born: rfc6238.php which contains helper class TokenAuth6238 with several useful functions

Generating a secret


A secret is used to provide a base for your application and the device generating the code to validate the user's identity. The secret is important and should be transfered over a secured channel. If attacker will get access to the secret, it's possible to generate the verification code and get around the security procedure.

<pre><code class="php">
secret = Base32::encode("yourrandomsecretkey")
</code></pre>



Google authenticator

Google provides Android and iPhone application that generates the verification code for the user.

Install the application and create new account by entering the a code. Name your account as you want and enter the secret generated in the previous step. Choose time based token.

Now you can see on you smartphone 6 character long password that allows you to validate the user's identity

 Validating the integrity

Now that we have the secret and the smartphone is generating the verification code, let's try to validate the it.

<pre><code class="php">

<?php require_once("rfc6238.php");
$secretkey = 'GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ';  //your secret code
$currentcode = '571427';  //code to validate, for example received from device


if (TokenAuth6238::verify($secretkey,$currentcode))
{
    echo "Code is valid\n";
}
else
{
    echo "Invalid code\n";
}
</code></pre>

Generating the code

You can also generate the verification code yourself using the library.

<pre><code class="php">

print TokenAuth6238::getTokenCodeDebug($secretkey,0);

</code></pre>

Generating the QRCode for GOOGLE Authenticator

You can also generate the image that can be used by mobile device to configure authentication program

<pre><code class="php">

print sprintf('<img src="%s"/>',TokenAuth6238::getBarCodeUrl('','',$secretkey));

</code></pre>

When you run such a script and you put in the correct secret and correct verification code, it will print "Code is valid" or "Invalid code" on the standard output.

#Points of Interest
Using this few simple steps, you can add additional validation layer into your authentication process in your application and thus provide higher security for your users.

Mentioned helper class for OTP can be forked at GitHub: https://github.com/Voronenko/PHPOTP
